#ifndef BOARD_H
#define BOARD_H

#include "globe.h"

#include "board_internal.h"
#include "board_revision_defs.h"
#include "pin_defs.h"

typedef enum fdoem_device { fdoem_o2, fdoem_ph, fdoem_undefined } fdoem_device;

void board_init();
void board_test();

inline void memory_barrier() { asm volatile("" ::: "memory"); }
void critical_section_enter(uint8_t *nest_context);
void critical_section_cleanup(uint8_t *nest_context);

void wait_for_event();

#define CRITICAL_SCOPE()                                                               \
    uint8_t __CRITICAL_SCOPE_NEST_CONTEXT                                              \
        __attribute__((__cleanup__(critical_section_cleanup))) = 0;                    \
    critical_section_enter(&__CRITICAL_SCOPE_NEST_CONTEXT);

typedef int64_t epoch_t;
epoch_t elapsed_ms();
void wait_until(epoch_t elapsed_ms);
void delay_ms(epoch_t dur_ms);

/* The callbacks provided to the asynchronous timers are scheduled as tasks
 * when the timer elapses. If a NULL pointer is passed then no callback is
 * scheduled.
 *
 * A timer must not leave scope as long as it is active. It is the
 * responsibility of the caller to maintain the lifetime of the timer.
 *
 * A timer that is default initialized will be in a valid stopped state.
 */
struct timer {
    void (*callback)(struct timer *timer);
    epoch_t starting_ms;
    epoch_t period_ms;
    int timer_id;
};

void start_periodic_timer(struct timer *timer, epoch_t period_ms,
                          void (*callback)(struct timer *timer));
void start_one_shot_timer(struct timer *timer, epoch_t duration_ms,
                          void (*callback)(struct timer *timer));
/* Stop the timer and discard any pending tasks generated by the timer. If the
 * timer has already been stopped then nothing will happen. */
void stop_timer(struct timer *timer);
bool timer_active(const struct timer *timer);

bool is_epoch_set();
epoch_t get_epoch_ms();
void set_epoch_ms(epoch_t epoch_ms);

typedef uint32_t pin_id;

struct spi_bus {
    pin_id miso;
    pin_id mosi;
    pin_id sck;
};

struct spi_device {
    const struct spi_bus *bus;
    pin_id cs;
};

enum spi_mode {
    SPI_MODE_0,
    SPI_MODE_1,
    SPI_MODE_2,
    SPI_MODE_3,
};

void spi_init(const struct spi_device *dev, enum spi_mode mode, uint8_t mosi_read_char,
              int max_freq_khz);
void spi_deinit(const struct spi_device *dev);
void spi_select(const struct spi_device *dev);
void spi_deselect(const struct spi_device *dev);
void spi_transfer(const struct spi_device *dev, const void *write_buf, void *read_buf,
                  size_t num_bytes);
void spi_read(const struct spi_device *dev, void *buf, size_t num_bytes);
void spi_write(const struct spi_device *dev, const void *buf, size_t num_bytes);

struct i2c_bus {
    pin_id scl;
    pin_id sda;
};

struct i2c_device {
    const struct i2c_bus *bus;
    uint8_t addr;
};

void i2c_init(const struct i2c_device *dev);
void i2c_deinit(const struct i2c_device *dev);
void i2c_read(const struct i2c_device *dev, void *buf, size_t num_bytes);
void i2c_write(const struct i2c_device *dev, const void *buf, size_t num_bytes,
               bool no_stop);

/* Transfer data over UART to the FDOEMO2 and read the response. The response
 * is assumed to be terminated by a carriage return character ('/r'). The
 * number of bytes in the response (including carriage return) is returned.
 *
 * Zero is returned on a timeout.
 */
size_t uart_fdoem_txrx(fdoem_device device, const void *tx_buf, size_t tx_len,
                       void *rx_buf, size_t rx_len);

typedef unsigned periph_mask_t;
#define PERIPH_MASK_COMM (1 << 0)
#define PERIPH_MASK_SD_CARD (1 << 1)
#define PERIPH_MASK_FDOEMO2 (1 << 2)
#define PERIPH_MASK_FDOEMPH (1 << 3)
#define PERIPH_MASK_MAX31856 (1 << 4)
#define PERIPH_MASK_BMX160_SPI (1 << 5)
#define PERIPH_MASK_BMX160_I2C (1 << 6)
#define PERIPH_MASK_BMX160 (PERIPH_MASK_BMX160_SPI | PERIPH_MASK_BMX160_I2C)
#define PERIPH_MASK_MCP3208 (1 << 7)
#define PERIPH_MASK_EEPROM (1 << 8)
#define PERIPH_MASK_THERMISTOR (1 << 9)
#define PERIPH_MASK_89BSD (1 << 10)
#define PERIPH_MASK_PHONY_SENSOR (1 << 11)

struct adc_channel {
    pin_id pin;
};

float adc_read(const struct adc_channel *chan);

/* Specify peripherals supported by this hardware.
 *
 * Note that certain peripherals are removable. This function does not check if
 * the peripheral is removed in the returned mask.
 */
periph_mask_t board_peripheral_support();

/* Ensure power is provided to the power lines of the specified peripherals.
 * Based on the required peripherals and hardware configuraion, more
 * peripherals than indicated may have to be powered. A mask of the powered
 * peripherals is returned.
 *
 * Note that certain peripherals are removable. This function does not check if
 * the peripheral is removed in the returned mask.
 */
periph_mask_t power_management_configure(periph_mask_t required_peripherals);

#define BOARD_TEMPERATURE_UNITS_PER_DEGREE 4

/* The board temperature in Celsius, multiplied by a factor of
 * BOARD_TEMPERATURE_UNITS_PER_DEGREE. */
int board_temperature();

extern const char *const device_id;

size_t stack_capacity();
size_t stack_maximum_usage();

/* Will always be non-null, but will point to an empty string if reset cause is
 * not available. */
const char *reset_cause();
const char *reset_debug_info();

struct ble_char;

struct ble_char_int {
    struct ble_char *c;
};

struct ble_char_float {
    struct ble_char *c;
};

struct ble_char_string {
    struct ble_char *c;
};

struct ble_char_bool {
    struct ble_char *c;
};

void init_ble_char_int(struct ble_char_int *c, uint16_t uuid, const char *label,
                       void (*write_callback)(struct ble_char_int *, int64_t value));
void init_ble_char_float(struct ble_char_float *c, uint16_t uuid, const char *label,
                         void (*write_callback)(struct ble_char_float *, float value));
void init_ble_char_string(struct ble_char_string *c, uint16_t uuid, const char *label,
                          void (*write_callback)(struct ble_char_string *,
                                                 const char *value));
void init_ble_char_bool(struct ble_char_bool *c, uint16_t uuid, const char *label,
                        void (*write_callback)(struct ble_char_bool *, bool value));

/* If the characteristic has not been initialized then the following 'set'
 * functions have no effect. */
void set_ble_char_int(struct ble_char_int *c, int64_t value);
void set_ble_char_float(struct ble_char_float *c, float value);
void set_ble_char_string(struct ble_char_string *c, const char *value);
void set_ble_char_bool(struct ble_char_bool *c, bool value);

void start_ble(void *context, const char *label, void (*on_uart_connect)(void *context),
               void (*on_uart_disconnect)(void *context),
               void (*on_uart_rx)(void *context, const char *string));

int ble_uart_send(const char *data, int len);

/* Wait for all pending UART data to be transmitted and acknowledged. */
int ble_uart_sync();

void ble_update_label(const char *label);

void reset_into_dfu_mode();

void set_ssbe_duty_cycle(int duty_cycle_pct);

#endif
